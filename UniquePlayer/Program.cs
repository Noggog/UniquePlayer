using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml.Linq;
using System.Threading;
using System.Threading.Tasks;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Noggog;
using Mutagen.Bethesda.FormKeys.SkyrimSE;

namespace UniquePlayer
{
    public class Program
    {
        static Lazy<Settings> Settings = null!;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
              .AddRunnabilityCheck(RunnabilityCheck)
              .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
              .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out Settings
              )
              .Run(args, new()
              {
                  ActionsForEmptyArgs = new()
                  {
                      IdentifyingModKey = "UniquePlayer.esp",
                      TargetRelease = GameRelease.SkyrimSE,
                  }
              });
        }

        private static void RunnabilityCheck(IRunnabilityState state)
        {
            var dataPath = state.Settings.DataFolderPath;
            if (Settings.Value.CustomBodyslideInstallPath)
            {
                dataPath = Settings.Value.BodySlideInstallPath;
            }
            BodySlidePaths(dataPath, out string outfitsPath, out string groupsPath);

            if (!(Directory.Exists(outfitsPath) && Directory.Exists(groupsPath)))
                throw new FileNotFoundException("Bodyslide installation not in default location, cannot proceed.");
        }

        private static void BodySlidePaths(string dataPath, out string outfitsPath, out string groupsPath)
        {
            var bodySlidePath = dataPath + "\\CalienteTools\\BodySlide\\";
            outfitsPath = bodySlidePath + "SliderSets";
            groupsPath = bodySlidePath + "SliderGroups";
        }

        public static readonly ModKey raceCompatibilityEsm = ModKey.FromNameAndExtension("RaceCompatibility.esm");

        public static readonly ModKey skyrimEsm = Constants.Skyrim;

        public static readonly Dictionary<FormKey, FormKey> vanillaRaceToActorProxyKeywords = new()
        {
            { Skyrim.Race.ArgonianRace, raceCompatibilityEsm.MakeFormKey(0x001D8B) }, // Argonian
            { Skyrim.Race.BretonRace, raceCompatibilityEsm.MakeFormKey(0x001D8A) }, // Breton
            { Skyrim.Race.DarkElfRace, raceCompatibilityEsm.MakeFormKey(0x001D8F) }, // DarkElf
            { Skyrim.Race.HighElfRace, raceCompatibilityEsm.MakeFormKey(0x001D8E) }, // HighElf
            { Skyrim.Race.ImperialRace, raceCompatibilityEsm.MakeFormKey(0x001D90) }, // Imperial
            { Skyrim.Race.KhajiitRace, raceCompatibilityEsm.MakeFormKey(0x001D8C) }, // Khajit
            { Skyrim.Race.NordRace, raceCompatibilityEsm.MakeFormKey(0x001D93) }, // Nord
            { Skyrim.Race.OrcRace, raceCompatibilityEsm.MakeFormKey(0x001D8D) }, // Orc
            { Skyrim.Race.RedguardRace, raceCompatibilityEsm.MakeFormKey(0x001D91) }, // Redguard
            { Skyrim.Race.WoodElfRace, raceCompatibilityEsm.MakeFormKey(0x001D92) }, // WoodElf
        };

        public static readonly FormKey playableRaceFormListFormKey = raceCompatibilityEsm.MakeFormKey(0x000D62);

        public static readonly FormKey playableVampireRaceFormListFormKey = raceCompatibilityEsm.MakeFormKey(0x000D63);

        public static readonly FormKey defaultRace = Skyrim.Race.DefaultRace;

        public static readonly Dictionary<FormKey, FormKey> replacementPlayableRacesDict = new();

        public static readonly Dictionary<FormKey, FormKey> replacementHeadParts = new();
        public static readonly HashSet<FormKey> inspectedHeadParts = new();

        public static readonly Dictionary<string, string> replacementTexturePathDict = new();
        public static readonly Dictionary<FormKey, FormKey> replacementTextureSets = new();
        public static readonly HashSet<string> inspectedTexturePaths = new();

        public static readonly Dictionary<string, string> replacementMeshPathDict = new();
        public static readonly HashSet<string> inspectedMeshPaths = new();

        public static readonly HashSet<FormKey> presetCharacters = new();

        public static readonly HashSet<string> seenDirectories = new();

        public static readonly string[] meshSuffixesWithTriFiles = {
            "_1.nif",
            ".nif"
        };

        /// <summary>
        /// Edits a path to a mesh file using Skyrim's mesh path rules.
        /// </summary>
        /// <param name="originalPath">The original mesh path.</param>
        /// <param name="injectedPath">The path components to insert after the top-level directory.</param>
        /// <returns></returns>
        public static string MangleMeshesPath(string originalPath, string injectedPath)
        {
            originalPath = originalPath.Replace('/', '\\');
            var indexOfMeshes = originalPath.IndexOf("Meshes\\");
            if (indexOfMeshes > 0)
                originalPath = originalPath[indexOfMeshes..];
            return $"Meshes\\{injectedPath}\\{originalPath}";
        }

        public static void CopyAndModifyOutfitFiles(string dataPath)
        {
            if (Settings.Value.CustomBodyslideInstallPath)
            {
                dataPath = Settings.Value.BodySlideInstallPath;
            }
            BodySlidePaths(dataPath, out string outfitsPath, out string groupsPath);

            var outfitOutputFileName = "\\UniquePlayer.osp";
            var groupOutputFileName = "\\UniquePlayer.xml";

            var oldToNewOutfitNames = new Dictionary<string, string>();

            static XDocument? tryLoad(string path)
            {
                try
                {
                    return XDocument.Load(path, LoadOptions.PreserveWhitespace);
                }
                catch (Exception e)
                {
                    Console.WriteLine(e);
                    return null;
                }
            }

            var outfitsData =
                from filePath in Directory.GetFiles(outfitsPath)//.AsParallel()
                where filePath.EndsWith(".osp")
                  && !filePath.EndsWith(outfitOutputFileName)
                where File.Exists(filePath)
                let doc = tryLoad(filePath)
                where doc is not null
                let sliderSets = doc.Element("SliderSetInfo")?.Elements("SliderSet")
                where sliderSets is not null
                from sliderSet in sliderSets
                select sliderSet;

            var outfitGroups =
                from filePath in Directory.GetFiles(groupsPath)//.AsParallel()
                where filePath.EndsWith(".xml")
                   && !filePath.EndsWith(groupOutputFileName)
                where File.Exists(filePath)
                let doc = tryLoad(filePath)
                where doc is not null
                let outfitGroups2 = doc.Element("SliderGroups")?.Elements("Group")
                where outfitGroups2 is not null
                from outfitGroup in outfitGroups2
                let outfitGroupName = outfitGroup.Attribute("name")?.Value
                where outfitGroupName is not null
                group outfitGroup by outfitGroupName;

            var outfitsDoc = new XDocument(
                new XDeclaration("1.0", "utf-8", "yes")
            );
            var sliderSetInfo = new XElement("SliderSetInfo", new XAttribute("version", "1"));
            outfitsDoc.Add(sliderSetInfo);

            var sliderGroupDoc = new XDocument();
            var sliderGroups = new XElement("SliderGroups");
            sliderGroupDoc.Add(sliderGroups);
            var sliderGroup = new XElement("Group", new XAttribute("name", "Unique Player"));
            sliderGroups.Add(sliderGroup);

            foreach (var outfitData in outfitsData)
            {
                var outfitPathElement = outfitData.Element("OutputPath");
                var outfitNameElement = outfitData.Element("name");
                if (outfitPathElement is null || outfitNameElement is null) continue;
                outfitPathElement.Value = MangleMeshesPath(outfitPathElement.Value, "Player");
                var oldOutfitName = outfitNameElement.Value;
                var newOutfitName = oldOutfitName + " (Unique Player)";
                outfitNameElement.Value = newOutfitName;
                sliderSetInfo.Add(outfitData);
                sliderGroup.Add(new XElement("Member", new XAttribute("name", newOutfitName)));
                oldToNewOutfitNames.Add(oldOutfitName, newOutfitName);
            }

            // attempt to coalesce the same groups defined in multiple files.
            foreach (var outfitGroupGroup in outfitGroups)
            {
                var combinedOutfitGroup = outfitGroupGroup.First();
                var combinedOutfitGroupNameAttribute = combinedOutfitGroup.Attribute("name");
                if (combinedOutfitGroupNameAttribute is null) continue;
                combinedOutfitGroupNameAttribute.Value = outfitGroupGroup.Key + " (Unique Player)";
                foreach (var outfitGroup in outfitGroupGroup.Skip(1))
                    combinedOutfitGroup.Add(outfitGroup.Elements("Member"));
                foreach (var member in combinedOutfitGroup.Elements("Member"))
                {
                    var memberNameAttribute = member.Attribute("name");
                    if (memberNameAttribute is null) continue;
                    if (oldToNewOutfitNames.TryGetValue(memberNameAttribute.Value, out var newOutfitName))
                        memberNameAttribute.Value = newOutfitName;
                }

                sliderGroups.Add(combinedOutfitGroup);
            }

            outfitsDoc.Save(outfitsPath + outfitOutputFileName);
            sliderGroupDoc.Save(groupsPath + groupOutputFileName);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            var linkCache = state.LinkCache;

            CopyAndModifyOutfitFiles(state.Settings.DataFolderPath);

            var playableRaceFormList = linkCache.Resolve<IFormListGetter>(playableRaceFormListFormKey);
            var playableVampireRaceFormList = linkCache.Resolve<IFormListGetter>(playableVampireRaceFormListFormKey);

            var playableRaceFormLinks = playableRaceFormList.ContainedFormLinks;
            var playableVampireRaceFormLinks = playableVampireRaceFormList.ContainedFormLinks;

            if (playableRaceFormLinks.Count() != playableVampireRaceFormLinks.Count())
                throw new Exception("The number of playable races and the number of playable vampire races does not match, cannot proceed.");

            var victimRaceFormKeys = playableRaceFormLinks.Select(x => x.FormKey).Concat(playableVampireRaceFormLinks.Select(x => x.FormKey)).ToHashSet();


            var otherFormLists =
                from x in state.LoadOrder.PriorityOrder.WinningOverrides<IFormListGetter>()
                where x.FormKey != playableRaceFormListFormKey
                && x.FormKey != playableVampireRaceFormListFormKey
                && x.ContainedFormLinks.Any(y => victimRaceFormKeys.Contains(y.FormKey))
                select state.PatchMod.FormLists.GetOrAddAsOverride(x);

            var modifiedPlayableRaceFormList = state.PatchMod.FormLists.GetOrAddAsOverride(playableRaceFormList);
            var modifiedPlayableVampireRaceFormList = state.PatchMod.FormLists.GetOrAddAsOverride(playableVampireRaceFormList);

            var texturesPath = state.Settings.DataFolderPath + "\\Textures\\";
            var meshesPath = state.Settings.DataFolderPath + "\\Meshes\\";

            string? changeTexturePath(string? path, ref bool changed)
            {
                if (path is null) return null;
                if (inspectedTexturePaths.Contains(path)) return path;
                if (replacementTexturePathDict.TryGetValue(path, out var newPath))
                {
                    changed = true;
                    return newPath;
                }

                newPath = "Player\\Textures\\" + path;
                if (File.Exists(texturesPath + newPath))
                {
                    replacementTexturePathDict.Add(path, newPath);
                    changed = true;
                    return newPath;
                }
                inspectedTexturePaths.Add(path);
                return path;
            }

            string changeMeshPath(string path, ref bool changed)
            {
                //if (path is null) return null;
                if (inspectedMeshPaths.Contains(path)) return path;
                if (replacementMeshPathDict.TryGetValue(path, out var newPath))
                {
                    changed = true;
                    return newPath;
                }

                newPath = MangleMeshesPath(path, "Player");

                if (!File.Exists(meshesPath + newPath))
                {
                    inspectedMeshPaths.Add(path);
                    return path;
                }

                replacementMeshPathDict.Add(path, newPath);
                changed = true;

                return newPath;
            }

            bool updateTextureSet(IFormLinkNullable<ITextureSetGetter> textureSetFormLink, IMajorRecordCommonGetter rec)
            {
                if (textureSetFormLink.IsNull) return false;
                var textureSetFormKey = textureSetFormLink.FormKey;
                if (replacementTextureSets.ContainsKey(textureSetFormKey)) return true;
                var txst = textureSetFormLink.TryResolve(state.LinkCache).Value;
                if (txst == null) throw RecordException.Factory(new NullReferenceException($"Could not find referenced TXST {textureSetFormLink}"), rec);

                var changed = false;
                changeTexturePath(txst.Diffuse, ref changed);
                changeTexturePath(txst.NormalOrGloss, ref changed);
                changeTexturePath(txst.EnvironmentMaskOrSubsurfaceTint, ref changed);
                changeTexturePath(txst.GlowOrDetailMap, ref changed);
                changeTexturePath(txst.Height, ref changed);
                changeTexturePath(txst.Environment, ref changed);
                changeTexturePath(txst.Multilayer, ref changed);
                changeTexturePath(txst.BacklightMaskOrSpecular, ref changed);

                if (!changed) return false;

                var newTxst = state.PatchMod.TextureSets.AddNew($"{txst.EditorID}_UniquePlayer");
                newTxst.DeepCopyIn(txst, new TextureSet.TranslationMask(defaultOn: true)
                {
                    EditorID = false
                });
                replacementTextureSets.Add(textureSetFormKey, newTxst.FormKey);

                newTxst.Diffuse = changeTexturePath(txst.Diffuse, ref changed);
                newTxst.NormalOrGloss = changeTexturePath(txst.NormalOrGloss, ref changed);
                newTxst.EnvironmentMaskOrSubsurfaceTint = changeTexturePath(txst.EnvironmentMaskOrSubsurfaceTint, ref changed);
                newTxst.GlowOrDetailMap = changeTexturePath(txst.GlowOrDetailMap, ref changed);
                newTxst.Height = changeTexturePath(txst.Height, ref changed);
                newTxst.Environment = changeTexturePath(txst.Environment, ref changed);
                newTxst.Multilayer = changeTexturePath(txst.Multilayer, ref changed);
                newTxst.BacklightMaskOrSpecular = changeTexturePath(txst.BacklightMaskOrSpecular, ref changed);
                return true;
            }

            void updateHeadPart(IFormLink<IHeadPartGetter> headPartItem, IMajorRecordCommonGetter race)
            {
                var headPartFormKey = headPartItem.FormKey;
                if (replacementHeadParts.ContainsKey(headPartFormKey)) return;
                if (inspectedHeadParts.Contains(headPartFormKey)) return;
                var headPart = headPartItem.Resolve(state.LinkCache);
                if (headPart == null) throw RecordException.Factory(new NullReferenceException($"Could not find referenced HDPT {headPartFormKey}"), race);

                var changed = false;

                if (!headPart.TextureSet.IsNull)
                    changed |= updateTextureSet(headPart.TextureSet, headPart);

                headPart.Parts.ForEach(x =>
                {
                    if (x.FileName != null) changeMeshPath(x.FileName, ref changed);
                });

                if (headPart.Model != null)
                    changeMeshPath(headPart.Model.File, ref changed);

                headPart.Model?.AlternateTextures?.ForEach(x =>
                {
                    changed |= updateTextureSet(x.NewTexture, headPart);
                });

                headPart.ExtraParts.ForEach(x =>
                {
                    updateHeadPart(x, headPart);
                });

                if (!changed)
                {
                    inspectedHeadParts.Add(headPartFormKey);
                    return;
                };

                var newHeadPart = state.PatchMod.HeadParts.AddNew($"{headPart.EditorID}_UniquePlayer");
                newHeadPart.DeepCopyIn(headPart, new HeadPart.TranslationMask(defaultOn: true)
                {
                    EditorID = false
                });
                // TODO duplicate headPart FormList and restrict to player only?

                newHeadPart.Parts.ForEach(x =>
                {
                    if (x.FileName != null) x.FileName = changeMeshPath(x.FileName, ref changed);
                });

                if (newHeadPart.Model != null)
                    newHeadPart.Model.File = changeMeshPath(newHeadPart.Model.File, ref changed);

                newHeadPart.RemapLinks(replacementTextureSets);
                replacementHeadParts.Add(headPartFormKey, newHeadPart.FormKey);
            }

            Race copyRace(IRaceGetter oldRace)
            {
                var newRace = state.PatchMod.Races.AddNew($"{oldRace.EditorID}_UniquePlayer");
                newRace.DeepCopyIn(oldRace, new Race.TranslationMask(defaultOn: true)
                {
                    EditorID = false,
                    ArmorRace = false
                });
                newRace.MorphRace = oldRace.FormKey;
                replacementPlayableRacesDict.Add(oldRace.FormKey, newRace.FormKey);

                var race = newRace;

                race.HeadData?.NotNull().ForEach(headData =>
                {
                    headData.FaceDetails.NotNull().ForEach(x => updateTextureSet(x, race));

                    headData.HeadParts.NotNull().ForEach(x => updateHeadPart(x.Head, oldRace));

                    foreach (var item in headData.TintMasks)
                    {
                        var junk = false;
                        item.FileName = changeTexturePath(item.FileName, ref junk);
                    }

                    presetCharacters.Add(headData.RacePresets.Select(x => x.FormKey));
                });
                race.RemapLinks(replacementTextureSets);
                race.RemapLinks(replacementHeadParts);

                return newRace;
            }

            Console.WriteLine("Creating new player-only races from existing playable races.");
            foreach (var (raceLink, vampireRaceLink) in Enumerable.Zip<FormLinkInformation, FormLinkInformation>(playableRaceFormLinks, playableVampireRaceFormLinks))
            {
                var raceFormKey = raceLink.FormKey;
                var vampireRaceFormKey = vampireRaceLink.FormKey;

                var race = linkCache.Resolve<IRaceGetter>(raceFormKey);
                var vampireRace = linkCache.Resolve<IRaceGetter>(vampireRaceFormKey);

                if (!race.Flags.HasFlag(Race.Flag.Playable))
                    throw RecordException.Factory(new Exception("Race in PlayableRaceList was not playable"), race);

                var newRace = copyRace(race);

                // add ActorProxy<race> for copies of vanilla races; it's assumed that either the non-vanilla race already has the appropriate ActorProxy<race>, or is happy with no ActorProxy<race>, and our copy should be the same.
                if (vanillaRaceToActorProxyKeywords.TryGetValue(raceFormKey, out var actorProxyKeywordFormKey))
                    (newRace.Keywords ??= new()).Add(actorProxyKeywordFormKey);

                var newVampireRace = copyRace(vampireRace);

                var modifiedRace = state.PatchMod.Races.GetOrAddAsOverride(race);
                modifiedRace.Flags ^= Race.Flag.Playable;
                modifiedRace.HeadData?.ForEach(x => x?.RacePresets.RemoveAll(x => true));

                foreach (var otherFormList in otherFormLists)
                {
                    var formLinks = otherFormList.ContainedFormLinks;
                    if (formLinks.Any(x => x.FormKey == raceFormKey))
                        otherFormList.Items.Add(newRace);
                    if (formLinks.Any(x => x.FormKey == vampireRaceFormKey))
                        otherFormList.Items.Add(newVampireRace);
                }
            }

            Console.WriteLine("Replacing the list of playable races (as supported by RaceCompatability.esm) with the newly created races.");
            modifiedPlayableRaceFormList.RemapLinks(replacementPlayableRacesDict);
            modifiedPlayableVampireRaceFormList.RemapLinks(replacementPlayableRacesDict);

            Console.WriteLine("Changing Player's race to our newly created player-only Race");
            state.PatchMod.Npcs.GetOrAddAsOverride(linkCache.Resolve<INpcGetter>(skyrimEsm.MakeFormKey(0x000007))).RemapLinks(replacementPlayableRacesDict);

            foreach (var item in presetCharacters)
            {
                state.PatchMod.Npcs.GetOrAddAsOverride(linkCache.Resolve<INpcGetter>(item)).RemapLinks(replacementPlayableRacesDict);
            }

            // TODO only do armor addons that are used by playable armor?
            Console.WriteLine("Creating new ArmorAddons that use player-specific meshes or editing existing ArmorAddons to support newly added races.");

            var armorAddonAdditions = new Dictionary<FormKey, FormKey>();

            foreach (var armorAddon in state.LoadOrder.PriorityOrder.WinningOverrides<IArmorAddonGetter>().Where(x => victimRaceFormKeys.Contains(x.Race.FormKey) || x.AdditionalRaces.Any(y => victimRaceFormKeys.Contains(y.FormKey))).ToList())
            {
                bool needsEdit = false;
                var races = armorAddon.AdditionalRaces.Select(x => x.FormKey).Append(armorAddon.Race.FormKey);

                var replacementRaces = races.Where(x => victimRaceFormKeys.Contains(x)).Select(x => replacementPlayableRacesDict[x]).ToList();

                void modelNeedsEdit(IModelGetter? model)
                {
                    if (model is null) return;
                    changeMeshPath(model.File, ref needsEdit);
                    model.AlternateTextures?.ForEach(alternateTexture => needsEdit |= updateTextureSet(alternateTexture.NewTexture, armorAddon));
                }

                void applyModelEdit(Model? model)
                {
                    if (model is null) return;
                    model.File = changeMeshPath(model.File, ref needsEdit);
                    // model.AlternateTextures covered by running RemapLinks at the top level.
                }

                armorAddon.FirstPersonModel?.ForEach(modelNeedsEdit);
                armorAddon.WorldModel?.ForEach(modelNeedsEdit);

                armorAddon.SkinTexture?.ForEach(x =>
                {
                    if (!x.IsNull) needsEdit |= updateTextureSet(x, armorAddon);
                });

                if (needsEdit)
                {
                    var newArmorAddon = state.PatchMod.ArmorAddons.AddNew($"{armorAddon.EditorID}_UniquePlayer");
                    newArmorAddon.DeepCopyIn(armorAddon, new ArmorAddon.TranslationMask(defaultOn: true)
                    {
                        EditorID = false,
                        Race = false,
                        AdditionalRaces = false
                    });
                    newArmorAddon.Race = new(replacementRaces.Take(1).Single());
                    replacementRaces.Skip(1).ForEach(x => newArmorAddon.AdditionalRaces.Add(x));

                    newArmorAddon.FirstPersonModel?.ForEach(applyModelEdit);
                    newArmorAddon.WorldModel?.ForEach(applyModelEdit);

                    newArmorAddon.RemapLinks(replacementTextureSets);

                    armorAddonAdditions.Add(armorAddon.FormKey, newArmorAddon.FormKey);

                    // remove defaultRace from base armorAddons?
                    if (races.Contains(defaultRace) && false)
                    {
                        var modifiedArmorAddon = state.PatchMod.ArmorAddons.GetOrAddAsOverride(armorAddon);
                        if (modifiedArmorAddon.Race == defaultRace)
                        {
                            var firstRace = modifiedArmorAddon.AdditionalRaces.First().FormKey;
                            modifiedArmorAddon.Race = firstRace;
                            modifiedArmorAddon.AdditionalRaces.Remove(firstRace);
                        }
                        else
                        {
                            modifiedArmorAddon.AdditionalRaces.Remove(defaultRace);
                        }
                    }
                }
                else
                    state.PatchMod.ArmorAddons.GetOrAddAsOverride(armorAddon).AdditionalRaces.AddRange(replacementRaces);
            }

            var armors =
                from armor in state.LoadOrder.PriorityOrder.WinningOverrides<IArmorGetter>()
                where (!armor.MajorFlags.HasFlag(Armor.MajorFlag.NonPlayable))
                && armor.TemplateArmor.IsNull
                && armor.Armature.Any(y => armorAddonAdditions.ContainsKey(y.FormKey))
                select state.PatchMod.Armors.GetOrAddAsOverride(armor);

            Console.WriteLine("Registering new ArmorAddons with Armors");
            foreach (var armor in armors)
                foreach (var item in armor.Armature.ToList())
                    if (armorAddonAdditions.TryGetValue(item.FormKey, out var value))
                        armor.Armature.Insert(0, new FormLink<IArmorAddonGetter>(value));
        }
    }
}
